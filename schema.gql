# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

schema {
  query: Query
  mutation: Mutation
}

"""
requires authorization

allowed forms:
    - http headers
        - Authorization: Bearer <token>
"""
directive @auth(
  """
  there is required additional confirmation by password
  send password in 'Authorization-Confirm' header
  """
  confirmationRequired: Boolean = false
  """if resource is not owned by current user field is nulled"""
  onlyOwn: Boolean = false
  optional: Boolean = false
  """
  permissions required to complete action
  authed user MUST have ALL of these permissions
  """
  permissions: [Permissions!] = []
) on FIELD_DEFINITION

directive @constraint(contains: String, endsWith: String, exclusiveMax: Float, exclusiveMin: Float, format: String, max: Float, maxLength: Int, min: Float, minLength: Int, multipleOf: Float, notContains: String, pattern: String, startsWith: String, uniqueTypeName: String) on ARGUMENT_DEFINITION | FIELD_DEFINITION | INPUT_FIELD_DEFINITION

"""
recaptcha token must be specified in 'recaptcha' header
it also must match 'actionName'
"""
directive @recaptchaV3(actionName: String!) on FIELD_DEFINITION

type ArticleEntity {
  author: UserEntity!
  content: [ArticleRevisionEntity!]!
  createdAt: DateTime!
  id: ID!
  opinions: [ArticleOpinion!]!
}

type ArticleOpinion {
  author: UserEntity
  content: String
  id: ID!
  """integer in range 1-10"""
  stars: Int!
  target: ArticleEntity!
}

type ArticleRevisionEntity {
  categories: [CategorieEntity!]!
  content: String!
  editedAt: DateTime!
  editedBy: UserEntity!
  id: ID!
}

type AuthPayload {
  token: TokenEntity!
  user: UserEntity!
}

"""

        example state before creation

        root
        ├ one
        | ├ two
        | └ three
        ├ four
        └ five

        using
          name: six
          id: (here use id coresponding to one)

        if creation mode is set to DESCENDANT this will add new categorie under specified id
        the result will be:

        root
        ├ one
        | ├ six
        | ├ two
        | └ three
        ├ four
        └ five

        if creation mode is set to ANCESTOR this will add new categorie over specified id
        the result will be:

        root
        ├ six
        | └ one
        |   ├ two
        |   └ three
        ├ four
        └ five
    
"""
enum CategorieCreationMode {
  ANCESTOR
  DESCENDANT
}

type CategorieEntity {
  id: ID!
  name: String!
  parentId: ID
}

type Channel {
  content: [ChannelRevision!]!
  lastSyncWithYT: DateTime!
  name: String!
  opinions: [ChannelOpinion!]!
  ytId: ID!
}

type ChannelOpinion {
  author: UserEntity
  content: String
  id: ID!
  """integer in range 1-10"""
  stars: Int!
  target: Channel!
}

type ChannelProposal {
  description: String!
  id: ID!
  socialMedia: [SocialMediaEntity!]!
  ytId: ID!
}

type ChannelRevision {
  categories: [CategorieEntity!]!
  description: String!
  editedBy: UserEntity!
  id: ID!
  socialMedia: [SocialMediaEntity!]!
}

input CreateArticleInput {
  content: String!
}

input CreateCategorieInput {
  categorieId: ID!
  mode: CategorieCreationMode!
  name: String!
}

input CreateOpinionInput {
  content: String @constraint(max: 500)
  stars: Int! @constraint(max: 10, min: 1)
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input LoginInput {
  deviceName: String!
  email: String! @constraint(format: "email")
  password: String! @constraint(minLength: 8)
}

type Mutation {
  acceptChannelProposal(edit: ProposeChannelInput, id: ID!): Channel! @auth(permissions: [ACCEPT_PROPOSAL])
  acceptYoutuberProposal(edit: ProposeYoutuberInput, id: ID!): YoutuberEntity! @auth(permissions: [ACCEPT_PROPOSAL])
  changeArticleVisibility(id: ID!): ArticleEntity! @auth(permissions: [EDIT_ARTICLE])
  """user can not modify own permissions!"""
  changePermissions(permissions: UpdatePermissionInput!): UserEntity! @recaptchaV3(actionName: "change-permissions") @auth(confirmationRequired: true, permissions: [MODIFY_PERMISSION])
  commentArticle(articleId: ID!, opinion: CreateOpinionInput!): ArticleOpinion! @auth(optional: true, permissions: [COMMENT])
  commentChannel(channelId: ID!, opinion: CreateOpinionInput!): ChannelOpinion! @auth(optional: true, permissions: [COMMENT])
  commentYoutuber(opinion: CreateOpinionInput!, youtuberId: ID!): YoutuberOpinion! @auth(optional: true, permissions: [COMMENT])
  createCategorie(createCategorieInput: CreateCategorieInput!): CategorieEntity!
  destroyToken(logout: String!): TokenEntity! @recaptchaV3(actionName: "logout-device") @auth(confirmationRequired: true)
  login(login: LoginInput!): AuthPayload! @recaptchaV3(actionName: "login")
  logout: TokenEntity! @recaptchaV3(actionName: "logout") @auth
  proposeChannel(proposal: ProposeChannelInput!): ChannelProposal! @auth
  proposeYoutuber(proposal: ProposeYoutuberInput!): YoutuberProposal! @auth
  register(register: RegisterInput!): AuthPayload! @recaptchaV3(actionName: "register")
  rejectChannelProposal(id: ID!): ChannelProposal @auth(permissions: [ACCEPT_PROPOSAL])
  rejectYoutuberProposal(id: ID!): YoutuberProposal @auth(permissions: [ACCEPT_PROPOSAL])
  removeCategorie(id: ID!): CategorieEntity!
  renameCategorie(updateCategorieInput: UpdateCategorieInput!): CategorieEntity!
  updateArticle(updateArticleInput: UpdateArticleInput!): ArticleEntity! @auth(permissions: [EDIT_ARTICLE])
  updateUser(updateUserInput: UpdateUserInput!): UserEntity! @auth
  writeArticle(createArticleInput: CreateArticleInput!): ArticleEntity! @auth(permissions: [WRITE_ARTICLE])
}

input PageInput {
  skip: Int = 0 @constraint(min: 0)
  take: Int = 10 @constraint(exclusiveMin: 0, max: 20)
}

enum Permissions {
  ACCEPT_PROPOSAL
  COMMENT
  EDIT_ARTICLE
  MODIFY_PERMISSION
  PROPOSE
  WRITE_ARTICLE
}

input ProposeChannelInput {
  categories: [ID!]!
  description: String!
  socialMedia: [SocialMediaInput!]!
  ytId: ID!
}

input ProposeYoutuberInput {
  birthday: DateTime
  categories: [ID!]!
  description: String!
  name: String!
  realName: String
  socialMedia: [SocialMediaInput!]!
  youtuberId: ID
}

type Query {
  """
  if authed user permissions include EDIT_ARTICLE hiden articles will be shown
  """
  article(id: ID!): ArticleEntity @auth(optional: true)
  channel(ytId: ID!): Channel
  channelProposals(page: PageInput!, ytId: ID): [ChannelProposal!]! @auth(permissions: [ACCEPT_PROPOSAL])
  """
  categories are returned in flat normalized array
  id defaults to ROOT categorie
  """
  subCategories(id: ID): [CategorieEntity!]!
  user(id: ID!): UserEntity
  youtuber(id: ID!): YoutuberEntity
}

input RegisterInput {
  deviceName: String!
  email: String! @constraint(format: "email")
  name: String! @constraint(minLength: 3)
  password: String! @constraint(minLength: 8)
}

enum SocialMedia {
  FACEBOOK
  INSTAGRAM
  SNAPCHAT
  TIKTOK
  TWITTER
}

type SocialMediaEntity {
  kind: SocialMedia!
  value: String!
}

input SocialMediaInput {
  kind: SocialMedia!
  value: String!
}

type TokenEntity {
  name: String!
  owner: UserEntity!
  token: String!
}

input UpdateArticleInput {
  content: String
  id: ID!
}

input UpdateCategorieInput {
  categorieId: ID!
  name: String!
}

input UpdatePermissionInput {
  add: [Permissions!] = []
  remove: [Permissions!] = []
  userId: ID!
}

input UpdateUserInput {
  email: String @constraint(format: "email")
  name: String @constraint(minLength: 3)
}

type UserEntity {
  email: String!
  id: ID!
  name: String!
  """by default every user receives [COMMENT, PROPOSE]"""
  permissions: [Permissions!]!
}

type YoutuberEntity {
  content: [YoutuberRevisionEntity!]!
  id: ID!
  opinions: [YoutuberOpinion!]!
}

type YoutuberOpinion {
  author: UserEntity
  content: String
  id: ID!
  """integer in range 1-10"""
  stars: Int!
  target: YoutuberEntity!
}

type YoutuberProposal {
  birthday: DateTime
  description: String!
  id: ID!
  name: String!
  realName: String
  socialMedia: [SocialMediaEntity!]!
  youtuberId: String
}

type YoutuberRevisionEntity {
  birthday: DateTime
  categories: [CategorieEntity!]!
  description: String!
  editedBy: UserEntity!
  id: ID!
  name: String!
  realName: String
  socialMedia: [SocialMediaEntity!]!
}