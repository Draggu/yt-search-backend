# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

schema {
  query: Query
  mutation: Mutation
}

"""
requires authorization

allowed forms:
    - http headers
        - Authorization: Bearer <token>
"""
directive @auth(
  """
  there is required additional confirmation by password
  send password in 'Authorization-Confirm' header
  """
  confirmationRequired: Boolean = false
  """if resource is not owned by current user field is nulled"""
  onlyOwn: Boolean = false
  optional: Boolean = false
) on FIELD_DEFINITION

directive @constraint(contains: String, endsWith: String, exclusiveMax: Float, exclusiveMin: Float, format: String, max: Float, maxLength: Int, min: Float, minLength: Int, multipleOf: Float, notContains: String, pattern: String, startsWith: String, uniqueTypeName: String) on ARGUMENT_DEFINITION | FIELD_DEFINITION | INPUT_FIELD_DEFINITION

"""
recaptcha token must be specified in 'recaptcha' header
it also must match 'actionName'
"""
directive @recaptchaV3(actionName: String!) on FIELD_DEFINITION

type ArticleEntity {
  """this does not include original Author! There is no order guarantee!"""
  allEditors: [UserEntity!]!
  author: UserEntity!
  content: ArticleRevisionEntity!
  createdAt: DateTime!
  id: ID!
  opinions: [ArticleOpinion!]!
}

type ArticleOpinion {
  author: UserEntity
  content: String
  id: ID!
  """integer in range 1-10"""
  stars: Int!
  target: ArticleEntity!
}

type ArticleRevisionEntity {
  categories: [CategorieEntity!]!
  content: String!
  editedAt: DateTime!
  editedBy: UserEntity!
  id: ID!
  isHiden: Boolean!
  previous: ArticleRevisionEntity
}

type AuthPayload {
  token: TokenEntity!
  user: UserEntity!
}

"""

        example state before creation

        root
        ├ one
        | ├ two
        | └ three
        ├ four
        └ five

        using
          name: six
          id: (here use id coresponding to one)

        if creation mode is set to DESCENDANT this will add new categorie under specified id
        the result will be:

        root
        ├ one
        | ├ six
        | ├ two
        | └ three
        ├ four
        └ five

        if creation mode is set to ANCESTOR this will add new categorie over specified id
        the result will be:

        root
        ├ six
        | └ one
        |   ├ two
        |   └ three
        ├ four
        └ five
    
"""
enum CategorieCreationMode {
  ANCESTOR
  DESCENDANT
}

type CategorieEntity {
  id: ID!
  name: String!
  parentId: ID
}

type ChannelEntity {
  content: ChannelRevisionEntity!
  lastSyncWithYT: DateTime!
  name: String!
  opinions: [ChannelOpinion!]!
  ytId: ID!
}

type ChannelOpinion {
  author: UserEntity
  content: String
  id: ID!
  """integer in range 1-10"""
  stars: Int!
  target: ChannelEntity!
}

input ChannelProposalInput {
  categories: [ID!]!
  description: String!
  ytId: ID!
}

type ChannelRevisionEntity {
  categories: [CategorieEntity!]!
  description: String!
  editedBy: UserEntity!
  id: ID!
}

input CreateArticleInput {
  content: String!
}

input CreateCategorieInput {
  categorieId: ID!
  mode: CategorieCreationMode!
  name: String!
}

input CreateOpinionInput {
  content: String @constraint(max: 500)
  stars: Int! @constraint(max: 10, min: 1)
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input LoginInput {
  deviceName: String!
  email: String! @constraint(format: "email")
  password: String! @constraint(minLength: 8)
}

type Mutation {
  commentArticle(articleId: ID!, opinion: CreateOpinionInput!): ArticleOpinion! @auth(optional: true)
  commentChannel(channelId: ID!, opinion: CreateOpinionInput!): ChannelOpinion! @auth(optional: true)
  commentYoutuber(opinion: CreateOpinionInput!, youtuberId: ID!): YoutuberOpinion! @auth(optional: true)
  createCategorie(createCategorieInput: CreateCategorieInput!): CategorieEntity!
  destroyToken(logout: String!): TokenEntity! @recaptchaV3(actionName: "logout-device") @auth(confirmationRequired: true)
  login(login: LoginInput!): AuthPayload! @recaptchaV3(actionName: "login")
  logout: TokenEntity! @recaptchaV3(actionName: "logout") @auth
  proposeChannel(proposal: ChannelProposalInput!): ChannelEntity! @auth
  proposeYoutuber(proposal: ProposeYoutuberInput!): YoutuberEntity! @auth
  register(register: RegisterInput!): AuthPayload! @recaptchaV3(actionName: "register")
  removeCategorie(id: ID!): CategorieEntity!
  removeUser: UserEntity! @auth
  renameCategorie(updateCategorieInput: UpdateCategorieInput!): CategorieEntity!
  updateArticle(updateArticleInput: UpdateArticleInput!): ArticleEntity! @auth
  updateUser(updateUserInput: UpdateUserInput!): UserEntity! @auth
  writeArticle(createArticleInput: CreateArticleInput!): ArticleEntity! @auth
}

input ProposeYoutuberInput {
  birthday: DateTime
  categories: [ID!]!
  description: String!
  name: String!
  realName: String
}

type Query {
  article(id: ID!): ArticleEntity
  channel(ytId: ID!): ChannelEntity
  """
  categories are returned in flat normalized array
  id defaults to ROOT categorie
  """
  subCategories(id: ID): [CategorieEntity!]!
  user(id: ID!): UserEntity
  youtuber(id: ID!): YoutuberEntity
}

input RegisterInput {
  deviceName: String!
  email: String! @constraint(format: "email")
  name: String! @constraint(minLength: 3)
  password: String! @constraint(minLength: 8)
}

type TokenEntity {
  name: String!
  owner: UserEntity!
  token: String!
}

input UpdateArticleInput {
  content: String
  id: ID!
  isHiden: Boolean
}

input UpdateCategorieInput {
  categorieId: ID!
  name: String!
}

input UpdateUserInput {
  email: String @constraint(format: "email")
  name: String @constraint(minLength: 3)
}

type UserEntity {
  email: String!
  id: ID!
  name: String!
  password: String!
}

type YoutuberEntity {
  content: YoutuberRevisionEntity!
  id: ID!
  opinions: [YoutuberOpinion!]!
}

type YoutuberOpinion {
  author: UserEntity
  content: String
  id: ID!
  """integer in range 1-10"""
  stars: Int!
  target: YoutuberEntity!
}

type YoutuberRevisionEntity {
  birthday: DateTime
  categories: [CategorieEntity!]!
  description: String!
  editedBy: UserEntity!
  id: ID!
  name: String!
  realName: String
}